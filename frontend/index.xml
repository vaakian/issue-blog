<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Frontends on Study Notes</title><link>https://notes.vaakian.com/frontend/</link><description>Recent content in Frontends on Study Notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 06 Mar 2022 14:11:03 +0800</lastBuildDate><atom:link href="https://notes.vaakian.com/frontend/index.xml" rel="self" type="application/rss+xml"/><item><title>implement async/await with generator/yield</title><link>https://notes.vaakian.com/frontend/async-generator/</link><pubDate>Sun, 06 Mar 2022 14:11:03 +0800</pubDate><guid>https://notes.vaakian.com/frontend/async-generator/</guid><description>async/await不是魔法，它只是一个语法糖，底层与生成器generator密不可分。 这里以学习为目的，简单用一个例子来模拟它们的行为，能够有一个直观的理解。
需要前置知识，这里不再解释：
ES6 async/await ES6 generator 创建一个异步加法函数 延迟1秒返回加法结果，方便实验。
function addAsync(x: number, y: number): Promise&amp;lt;number&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { setTimeout(() =&amp;gt; { resolve(x + y) }, 1000) }) } 实现单个yield（模拟await） function doAsync(g: () =&amp;gt; Generator): void { // 调用异步函数main，返回一个可迭代的iterator const it = g() // 调用next，运行到第一个yield之后暂停 const { value } = it.next() // 调用next则让yield之后的代码继续运行，并将v传递给yield作为返回值 value.then(v =&amp;gt; it.next(v)) } function* main() { const result: number = yield addAsync(5, 2) console.</description></item><item><title>Publish Ts Package</title><link>https://notes.vaakian.com/frontend/publish-ts-package/</link><pubDate>Tue, 25 Jan 2022 17:37:56 +0800</pubDate><guid>https://notes.vaakian.com/frontend/publish-ts-package/</guid><description> 草稿
由publish最近写的XPeer包引发的一系列新问题，记录学习所得。
XPeer是用TypeScript来写的，可以正常publish到npm上，但只能被ts项目所引用，而且需要反复编译，会浪费不少资源。
The 30-second guide to publishing a TypeScript package to NPM
预编译 tsc project 仅仅是将ts编译出原生js，前端项目能够直接import，不管是js还是ts项目。但不能通过浏览器&amp;lt;script&amp;gt;标签来引入。
browserify browserify能够对js进行bundle操作，让浏览器能够直接引入。至于什么是bundle？ tinify是browserify的压缩package，可以让bundle瘦身。 browserify-global-shim让某个包可以在windiw对象上全局访问。
配置 publish流程 npm init 配置package.json &amp;ldquo;main&amp;rdquo;: &amp;ldquo;lib/index.js&amp;rdquo;,即import的默认入口 &amp;ldquo;types&amp;rdquo;: &amp;ldquo;lib/index.d.ts&amp;rdquo;, 待考察 &amp;ldquo;exclude&amp;rdquo; &amp;ldquo;include&amp;rdquo; &amp;ldquo;declaration&amp;rdquo; 如何管理d.ts文件和types属性，让引包用户能够正常拿到type？
npm login
npm publish
使用 npm i -s xpeer
import { XPeer } from &amp;#39;xpeer&amp;#39; 总结</description></item><item><title>WebRTC: Signaling Server</title><link>https://notes.vaakian.com/frontend/webrtc-signaling-server/</link><pubDate>Fri, 21 Jan 2022 21:20:40 +0800</pubDate><guid>https://notes.vaakian.com/frontend/webrtc-signaling-server/</guid><description>Node.js服务端 服务端所需要做的事情：存储和广播房间信息 &amp;amp; 信令交换中介，包括sdp(SessionDescription)和ice(iceCandidate)。
接收基本的事件：join, offer, answer, icecandidate, leave
sdp用于协商会话连接方式之前的必要信息 ice协商的结果，用于候选的连接方式 客户端”仅在“join时带上id和nick，然后服务器存储该信息与Client对应。存储方式见：how to keep track of clients with WebSockets，或者直接在server.clients中挂载信息。
在offer和answer时，服务器取出对应的id和nick转发出去。
offer一定是广播，通过server.clients.forEach发送 answer是定向发送，带有receiverId，通过clientsMap发送 client对应表
class ClientsMap { constructor(server) { this.clients = new Map() server.on(&amp;#39;connection&amp;#39;, (ws, req) =&amp;gt; { ws.on(&amp;#39;message&amp;#39;, (message) =&amp;gt; { const data = JSON.parse(message) if (data.type === &amp;#39;join&amp;#39;) { this.clients.set(data.id, { id: data.id, nick: data.nick, ws: ws }) // 加入时，先注册好离开事件 ws.on(&amp;#39;close&amp;#39;, () =&amp;gt; { this.</description></item><item><title>Typescript</title><link>https://notes.vaakian.com/frontend/typescript/</link><pubDate>Fri, 21 Jan 2022 21:15:58 +0800</pubDate><guid>https://notes.vaakian.com/frontend/typescript/</guid><description>动态属性 对象动态属性 即某个对象的属性类型 依赖于 另外一个属性，当Message的type为offer时，payload的属性为RTCSessionDescriptionInit，而不是一个联合类型PeerInfo | RTCSessionDescriptionInit | RTCIceCandidateInit。
interface PeerInfo { id: string nick: string } interface PayloadMap { join: PeerInfo offer: RTCSessionDescriptionInit answer: RTCSessionDescriptionInit icecandidate: RTCIceCandidateInit // leave只有单接受情况，客户端不会主动发送。 leave: PeerInfo } type Message = { [K in keyof PayloadMap]: { type: K nick: string receiverId?: string | null // playload的类型取决于type的值 payload: PayloadMap[K] } }[keyof PayloadMap] 单拎出来这一段，其实是map出了多个类型，一个key对应一个类型。然后Message通过keyof PayloadMap来获取到一个联合类型。
const MessageTypeMap = { [K in keyof PayloadMap]: { type: K nick: string id: string receiverId?</description></item><item><title>WebRTC: Multi-RTCPeerCoonection</title><link>https://notes.vaakian.com/frontend/multi-rtcpeercoonection/</link><pubDate>Fri, 21 Jan 2022 16:24:57 +0800</pubDate><guid>https://notes.vaakian.com/frontend/multi-rtcpeercoonection/</guid><description>一）抛出问题 一个RTCPeerConnection只能对应另外一个RTCPeerCoonection，如果想要实现多人会议。那么需要统一管理多个RTCPeerConnection，任何本地数据都要广播到多个RTCPeerConnection中去。
二）职责分割 在通过纯原生的RTCPeerConnection实现双人一对一视频会议时，发现代码分隔时已经力不从心了。如何实现多人更需要一些明确的职责分割。
管理多个PeerConnection 将本地数据广播到多个PeerConnection *如何将PeerConnection与WebSocket中的Client绑定（如何识别身份） Track概念：管理多个Track到一个Stream中 本地Stream推到远程 2.1 如何识别身份 如何在WebSocket和PeerConnection建立连接过程中去确定身份，如何确定两者相关联？
首先要理清楚，建立连接的整个流程。然后找出应该在哪个阶段去进行身份确认。
加入房间，发送JoinRoom消息，带上自己的nick和id（唯一标识），服务器存储信息对应，回复房间Clients列表。 如果房间有人，发送Offer消息（带nick和id），服务器广播之后，其他人回复Answer消息（带个人信息和将要发往的id） 前端接收到Answer，将对应的PeerConnection与该id和nick对应。此后的连接就容易对应了。 peerConnection.createOffer() // 1. 创建offer .then(offer =&amp;gt; { return peerConnection.setLocalDescription(offer); }) .then(() =&amp;gt; { // 2. 发送offer（广播） return ws.send(JSON.stringify({ type: &amp;#39;offer&amp;#39;, nick: nick, id: id, sdp: peerConnection.localDescription })); }) .then(() =&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { // 3. 接收answer ws.onmessage = (event) =&amp;gt; { const data = JSON.</description></item><item><title>React Hooks</title><link>https://notes.vaakian.com/frontend/react-hooks/</link><pubDate>Tue, 18 Jan 2022 14:47:17 +0800</pubDate><guid>https://notes.vaakian.com/frontend/react-hooks/</guid><description>[TOC]
useMemo 千万不要把useMemo和React.memo混为一谈，两者都是根据依赖变化来缓存数据的。useMemo(fn, deps)参照第二个参数列表的变化返回新的数据，否则返回缓存的数据。而React.memo只会在组件的props变化时重新渲染该组件。
使用场景 有非常耗时的计算，比如以下例子中的expensiveComputation，每一次组件渲染，都会调用该函数，并且重新计算。但其实a和b并没有变化时，计算的值都是一样的，所以需要使用到useMemo将结果缓存下来，而无需重新计算。 function App() { const [a, setA] = useState(1) const [b, setB] = useState(2) // const value = expensiveComputation(a, b) const value = useMemo(() =&amp;gt; expensiveComputation(a, b), [a, b]) return &amp;lt;div&amp;gt;result: {value}&amp;lt;/div&amp;gt; } 任何hook的依赖为对象时，可能会遇到「字面上」相同，但不是同一个对象，所以会导致依赖判断错误。因为hook的依赖数组对比是浅层的对比，也就是 === 对比。因为每次渲染时，组件内的所有字面变量都会被重新创建，所以遇到对象应该要格外注意。 对象判定相等
const obj = {count: 1} console.log(obj === obj) // true // 引用不一样，所以为false console.log({count: 1} === {count: 1}) // false 以下例子，effect中的依赖是对象，虽然a, b没有发生变化，obj的字面上看起来也没用变化。但是在每次渲染时，都会创建一个新的对象，该对象引用不一样，所以每次都会执行effect。</description></item><item><title>WebRTC: RTCPeerConncetion</title><link>https://notes.vaakian.com/frontend/webrtc-connection/</link><pubDate>Sat, 15 Jan 2022 13:29:47 +0800</pubDate><guid>https://notes.vaakian.com/frontend/webrtc-connection/</guid><description>论文草稿
what is WebRTC WebRTC(Web Real-Time Communication)是一个最先由Google发布的点对点（Peer-to-Peer）通信协议，目前已经被各大浏览器所内置，早期不同浏览器的API有细微差别，需要开发者手动做兼容。现在可以使用MDN所推荐的WebRTC adapter.js来解决兼容问题。
其次它不仅仅适用于浏览器，也可以在任何其它不同平台的应用程序中使用，只要符合WebRTC的规范即可。
信道建立流程 两个实体（Peer）要建立连接或者说信道之前，需要先进行一项最最重要的工作，即信令交换。它将两个实体的信息（包含IP地址、端口等等各种用于建立连接的必要信息）进行互相交换，双方拿到信息后建立独立的信道。此后，两个实体就可以通过信道进行通信了，无需再通过服务器进行数据传输。
两种通信方式的优缺点 点对点通信方式不同于传统的中心化通信方式，需要一台或者多台服务器进行数据转发或者存储，这样会导致服务器的带宽和计算压力增大，而当服务器的负载增加时，会进而导致整个系统的稳定性下降，一旦中心服务器宕机，所有用户的通信将全部中断。而如果采用点对点通信方式，省去了服务器中转存储环节，降低了各个实体之间依赖性。用户之间可以直接通过网络进行通信，某个实体中断仅仅影响它自身，这样既可以节省服务器的资源，又提高了系统的稳定性。
不过，点对点通信也有自身的缺点，由于视频会议属于多对多的连接，每个实体要和其它所有实体都建立连接，随着系统中实体的增加，单个实体的压力也会随之增加。而采用的中心服务器转发存储方式就不会出现这种问题， 每个实体只需要和中心服务器建立连接，中心服务器负责存储数据和转发数据到其它实体。
所以，在实体较少、传输数据量大、网络延迟要求更高的场景下，点对点通信方式比较适合，反之，中心服务器转发存储方式比较适合。
RTCPeerConnection RTCPeerConnection负责很多事情，包括：
信令处理（singal processing） 编解码（Codec handling） 点对点连接（P2P connection） 安全（Security） 流量控制（bandwidth management） …… RTC创建连接过程主要是通过一个信令服务器进行SDP信息交换，这个过程可以通过WebSocket进行，也可以通过HTTP进行，当然WebSocket最佳。
const conn = new SomeWebsocketConn() const pc = new RTCPeerConnection(null) function sendOffer(desc) { // 发送offer到服务器上 conn.send({type: &amp;#39;offer&amp;#39;, sdp: desc}) // .then(gotAnswer) } // 当成功创建offer时调用 pc.createOffer(gotOffer) function gotOffer(desc) { pc.setLocalDescription(desc) // 发送到服务器 sendOffer(desc) } // 当服务器返回answer时调用 conn.</description></item><item><title>Vue响应式原理</title><link>https://notes.vaakian.com/frontend/vue-reactive/</link><pubDate>Fri, 14 Jan 2022 21:22:48 +0800</pubDate><guid>https://notes.vaakian.com/frontend/vue-reactive/</guid><description>开始 众所周知，Vue的响应式实现方式有两种，在Vue2中通过「Object.defineProperty」重新定义属性的descriptor中的getter/setter实现来。而Vue3通过ES6的“新人”「Proxy」来实现。
Vue2：Object.defineProperty 网传：&amp;ldquo;Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；&amp;rdquo;
纠错： 为什么Vue2中不劫持数组？
数组的位置不固定，数量多变，正常对象key对应value一般不会变，但是如果数组删除了某个元素，比如第一个元素被删除或者头部增加一个元素，那么将导致后面所有的key对应value错位，如果6个元素，也就会触发5次set。
数组元素可能非常非常多，每个元素进行劫持有一定浪费，这可能是Evan you对性能的考虑。
Vue2将数组的7个变异方法进行了重写，也就是更改了Array原型上的方法达到劫持变化。
Vue2将对象新增属性/数组修改等操作，通过Vue.set来统一实现，这样其实是直接告诉Vue自己的set行为，即要新增/修改的属性名，然后重新劫持或者通知修改Deps[key].notify()，Vue2才可以监测到「新增数据/数组下标」的变化。
以下代码测试拦截数组会发生的情况
const arr = [1, 2, 3, 4, 5, 6] for (let key in arr) { let value = arr[key] Object.defineProperty(arr, key, { get() { console.log(`get: ${key}`) return value }, set(newValue) { console.log(`set: ${key}to ${newValue}`) return value = newValue } }) } arr[0] = 999 // 打印：set：0 to 999 arr[3] // 打印：get：3 arr.</description></item><item><title>React之：自定义hooks: useCamera</title><link>https://notes.vaakian.com/frontend/usecamera/</link><pubDate>Tue, 14 Dec 2021 15:55:03 +0800</pubDate><guid>https://notes.vaakian.com/frontend/usecamera/</guid><description>⚠️注：从老博客迁移，可能有排版问题。
尝试用浏览器API封装一个读取摄像头视频流的useCamera自定义hooks，一步一步优化，总结一下得到目前为止的最佳实践。 首先，摄像头读取API需要传入最基本的参数constraints，通过promise方式得到stream后会展示到video标签上，那么useCamera应该接受一个能够读取到video标签的参数，那么首选ref，得到如下第一版代码：
function useCamera(constraints, videoRef) { const storedStream = useRef(null) // 当stream改变时，创建新的stop函数 const stop = useCallback(() =&amp;gt; { storedStream.current.getTracks().forEach(track =&amp;gt; track.stop()) }, [storedStream.current]) // 当constraints/videoRef改变时，创建新的start函数 const start = useCallback(() =&amp;gt; { navigator.mediaDevices.getUserMedia(constraints) .then(stream =&amp;gt; { console.log(&amp;#39;setting stream&amp;#39;) videoRef.current.srcObject = stream storedStreamRef.current = stream }) .catch(err =&amp;gt; { console.error(err) }) }, [constraints, videoRef]) // constraints改变时，stop上一次的媒体流并重新请求 useEffect(() =&amp;gt; { start() return stop }, [constraints]) return [start, stop] } 然后在组件中调用创建的hooks，功能上运行正常。</description></item><item><title>Introduction</title><link>https://notes.vaakian.com/frontend/introduction/</link><pubDate>Tue, 14 Jan 2020 20:09:20 +0800</pubDate><guid>https://notes.vaakian.com/frontend/introduction/</guid><description>Geting Started 从很久很久以前就想记录下来日常的学习笔记（不是博客），但都无疾而终。从wordpress=&amp;gt;Notion=&amp;gt;github issue都感觉差点味道。
而之前感觉通过hexo or hugo这种编译型的静态部署来记录又太麻烦，但现在需要它们的可定制性，索性还是尝试用hugo来继续记录吧。
为什么不是hexo？ written in Go, which it&amp;rsquo;s fast.
About 主前端，不过其它的也都有接触。
2022本科毕业，即将入职某大厂。</description></item></channel></rss>