<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Study Notes</title><link>https://notes.vaakian.com/</link><description>Recent content on Study Notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 15 Jan 2022 13:29:47 +0800</lastBuildDate><atom:link href="https://notes.vaakian.com/index.xml" rel="self" type="application/rss+xml"/><item><title>论文草稿：WebRTC--RTCPeerConncetion</title><link>https://notes.vaakian.com/frontend/webrtc-connection/</link><pubDate>Sat, 15 Jan 2022 13:29:47 +0800</pubDate><guid>https://notes.vaakian.com/frontend/webrtc-connection/</guid><description>what is WebRTC WebRTC(Web Real-Time Communication)是一个最先由Google发布的点对点（Peer-to-Peer）通信协议，目前已经被各大浏览器所内置，早期不同浏览器的API有细微差别，需要开发者手动做兼容。现在可以使用MDN所推荐的WebRTC adapter.js来解决兼容问题。
其次它不仅仅适用于浏览器，也可以在任何其它不同平台的应用程序中使用，只要符合WebRTC的规范即可。
信道建立流程 两个实体（Peer）要建立连接或者说信道之前，需要先进行一项最最重要的工作，即信令交换。它将两个实体的信息（包含IP地址、端口等等各种用于建立连接的必要信息）进行互相交换，双方拿到信息后建立独立的信道。此后，两个实体就可以通过信道进行通信了，无需再通过服务器进行数据传输。
两种通信方式的优缺点 点对点通信方式不同于传统的中心化通信方式，需要一台或者多台服务器进行数据转发或者存储，这样会导致服务器的带宽和计算压力增大，而当服务器的负载增加时，会进而导致整个系统的稳定性下降，一旦中心服务器宕机，所有用户的通信将全部中断。而如果采用点对点通信方式，省去了服务器中转存储环节，降低了各个实体之间依赖性。用户之间可以直接通过网络进行通信，某个实体中断仅仅影响它自身，这样既可以节省服务器的资源，又提高了系统的稳定性。
不过，点对点通信也有自身的缺点，由于视频会议属于多对多的连接，每个实体要和其它所有实体都建立连接，随着系统中实体的增加，单个实体的压力也会随之增加。而采用的中心服务器转发存储方式就不会出现这种问题， 每个实体只需要和中心服务器建立连接，中心服务器负责存储数据和转发数据到其它实体。
所以，在实体较少、传输数据量大、网络延迟要求更高的场景下，点对点通信方式比较适合，反之，中心服务器转发存储方式比较适合。
RTCPeerConnection RTCPeerConnection负责很多事情，包括：
信令处理（singal processing） 编解码（Codec handling） 点对点连接（P2P connection） 安全（Security） 流量控制（bandwidth management） …… RTC创建连接过程主要是通过一个信令服务器进行SDP信息交换，这个过程可以通过WebSocket进行，也可以通过HTTP进行，当然WebSocket最佳。
const conn = new SomeWebsocketConn() const pc = new RTCPeerConnection(null) function sendOffer(desc) { // 发送offer到服务器上 conn.send({type: &amp;#39;offer&amp;#39;, sdp: desc}) // .then(gotAnswer) } // 当成功创建offer时调用 pc.createOffer(gotOffer) function gotOffer(desc) { pc.setLocalDescription(desc) // 发送到服务器 sendOffer(desc) } // 当服务器返回answer时调用 conn.onAnswer(gotAnswer) function gotAnswer(desc) { // 当设置远程描述（SDP）之后，WebRTC就会开始创建连接 pc.</description></item><item><title>《送别》</title><link>https://notes.vaakian.com/daily/songbie/</link><pubDate>Fri, 14 Jan 2022 23:05:06 +0800</pubDate><guid>https://notes.vaakian.com/daily/songbie/</guid><description>长亭外，古道边，芳草碧连天。晚风拂柳笛声残，夕阳山外山。
天之涯，地之角，知交半零落。一壶浊酒尽余欢，今宵别梦寒。
长亭外，古道边，芳草碧连天。问君此去几时来，来时莫徘徊。
天之涯，地之角，知交半零落。人生难得是欢聚，惟有别离多。</description></item><item><title>Vue响应式原理</title><link>https://notes.vaakian.com/frontend/vue-reactive/</link><pubDate>Fri, 14 Jan 2022 21:22:48 +0800</pubDate><guid>https://notes.vaakian.com/frontend/vue-reactive/</guid><description>开始 众所周知，Vue的响应式实现方式有两种，在Vue2中通过「Object.defineProperty」重新定义属性的descriptor中的getter/setter实现来。而Vue3通过ES6的“新人”「Proxy」来实现。
Vue2：Object.defineProperty 网传：&amp;ldquo;Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；&amp;rdquo;
纠错： 为什么Vue2中不劫持数组？
数组的位置不固定，数量多变，正常对象key对应value一般不会变，但是如果数组删除了某个元素，比如第一个元素被删除或者头部增加一个元素，那么将导致后面所有的key对应value错位，如果6个元素，也就会触发5次set。
数组元素可能非常非常多，每个元素进行劫持有一定浪费，这可能是Evan you对性能的考虑。
Vue2将数组的7个变异方法进行了重写，也就是更改了Array原型上的方法达到劫持变化。
Vue2将对象新增属性/数组修改等操作，通过Vue.set来统一实现，这样其实是直接告诉Vue自己的set行为，即要新增/修改的属性名，然后重新劫持或者通知修改Deps[key].notify()，Vue2才可以监测到「新增数据/数组下标」的变化。
以下代码测试拦截数组会发生的情况
const arr = [1, 2, 3, 4, 5, 6] for (let key in arr) { let value = arr[key] Object.defineProperty(arr, key, { get() { console.log(`get: ${key}`) return value }, set(newValue) { console.log(`set: ${key}to ${newValue}`) return value = newValue } }) } arr[0] = 999 // 打印：set：0 to 999 arr[3] // 打印：get：3 arr.</description></item><item><title>Introduction</title><link>https://notes.vaakian.com/frontend/introduction/</link><pubDate>Tue, 14 Jan 2020 20:09:20 +0800</pubDate><guid>https://notes.vaakian.com/frontend/introduction/</guid><description>Geting Started 从很久很久以前就想记录下来日常的学习笔记（不是博客），但都无疾而终。从wordpress=&amp;gt;Notion=&amp;gt;github issue都感觉差点味道。
而之前感觉通过hexo or hugo这种编译型的静态部署来记录又太麻烦，但现在需要它们的可定制性，所以尝试用hugo来继续记录吧。
为什么不是hexo？ writen in Go, which it&amp;rsquo;s fast.
About 主前端，不过其它的也都有接触。
2022本科毕业，即将入职某大厂。</description></item><item><title>About Hugo</title><link>https://notes.vaakian.com/about/</link><pubDate>Wed, 09 Apr 2014 00:00:00 +0000</pubDate><guid>https://notes.vaakian.com/about/</guid><description>Hugo is the world’s fastest framework for building websites. It is written in Go.
It makes use of a variety of open source projects including:
https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Learn more and contribute on GitHub.</description></item></channel></rss>