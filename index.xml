<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Study Notes</title><link>https://note.vaakian.com/</link><description>Recent content on Study Notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 15 Apr 2022 15:48:02 +0800</lastBuildDate><atom:link href="https://note.vaakian.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Creating a Function and it's prototype</title><link>https://note.vaakian.com/frontend/prototype/</link><pubDate>Fri, 15 Apr 2022 15:48:02 +0800</pubDate><guid>https://note.vaakian.com/frontend/prototype/</guid><description>简单回顾prototype prototype可以作为实例之间共享数据的一块空间。所以往prototype上放置任何属性，都可以被所有实例访问到。
function Animal() { // this是实例本身 console.log(this.name) } Animal.prototype.name = &amp;#39;Animal&amp;#39; Animal.prototype.greet = function() { console.log(`hello, i am ${this.name}`) } const cat = new Animal() const dog = new Animal() cat.__proto__ === Animal.prototype === dog.__proto__ 当通过实例本身访问任何属性，其过程为：自身 =&amp;gt; __proto__ =&amp;gt; __proto__ 的 __proto__ =&amp;gt; null
所以
const dog = new Animal() // 相等 dog.greet === Animal.prototype.greet === dog.__proto__.greet 但如果将构造函数改为
function Animal() { this.greet = function () { console.log(`hello, i am ${this.</description></item><item><title>TypeScript: Covariance &amp; Contravariance</title><link>https://note.vaakian.com/frontend/covariance-and-contravariance/</link><pubDate>Fri, 15 Apr 2022 13:36:51 +0800</pubDate><guid>https://note.vaakian.com/frontend/covariance-and-contravariance/</guid><description>个人复习用，不做科普。
创建两个类，Dog是Animal的子类。
class Animal {} class Dog extends Animal { bark() {} } 实现一个判断类型的Type，判断T是否是U的子类。
type Assignable&amp;lt;T, U&amp;gt; = T extends U ? true : false 测试，符合结果。
type R4 = Assignable&amp;lt;Dog, Animal&amp;gt; // true 但将同样的问题放到函数的parameters上，就发生了与第一直觉不一样的情况。
type ConsumeAnimal = (target: Animal) =&amp;gt; Animal type ConsumeDog = (target: Dog) =&amp;gt; Dog type R1 = Assignable&amp;lt;Son, Father&amp;gt; // false type R2 = Assignable&amp;lt;Father, Son&amp;gt; // true type R3 = Assignable&amp;lt;Parameters&amp;lt;Son&amp;gt;, Parameters&amp;lt;Father&amp;gt;&amp;gt; // true 问题出在哪里？ 通过Google，找到两个关键词：covariance和contravariance</description></item><item><title>React18: useDeferredValue</title><link>https://note.vaakian.com/frontend/react18-usedeferredvalue/</link><pubDate>Wed, 13 Apr 2022 12:24:53 +0800</pubDate><guid>https://note.vaakian.com/frontend/react18-usedeferredvalue/</guid><description>useDeferredValue的功能 &amp;amp; 场景 想象一个非常耗时的组件SlowComponent，当每次重新渲染时，在渲染结束之前，整个JavaScript主线程被阻塞(block)，无法处理任何事件，处于假死状态。
所以以下的input在输入新的值时，需要等到所有组件被render，input框才会更新显示新的值。
而SlowComponent耗时大约1s才返回结果，所以从键盘输入 =&amp;gt; 到页面上显示结果，需要等待1s。
包括input输入框。
function App() { const [text, setText] = useState(&amp;#34;hello&amp;#34;) return ( &amp;lt;div className=&amp;#34;App&amp;#34;&amp;gt; &amp;lt;input value={text} onChange={e =&amp;gt; setText(e.target.value)} /&amp;gt; {/* SlowComponent组件非常耗时 */} &amp;lt;SlowComponent text={text} /&amp;gt; &amp;lt;/div&amp;gt; ) } // 通过React.memo优化，text不变时，返回缓存的渲染结果。 const SlowComponent = React.memo(({ text }) =&amp;gt; { const now = Date.now() while (Date.now() - now &amp;lt; 500) { // do nothing } return &amp;lt;div&amp;gt;{text}&amp;lt;/div&amp;gt; }) 在线测试，改变1次输入框，输入框需要在500ms后响应。
https://codesandbox.io/s/goofy-khayyam-3q410q?file=/src/App.js
那么可不可以先立刻渲染出input，再去渲染SlowComponent呢？
答案是可以的，将「渲染过程」从上面的1次，分成2次。
怎么分？就是useDeferredValue可以用到的场景：</description></item><item><title>React18: concurrent rendering</title><link>https://note.vaakian.com/frontend/react18/</link><pubDate>Tue, 12 Apr 2022 14:56:18 +0800</pubDate><guid>https://note.vaakian.com/frontend/react18/</guid><description>React18更新了什么？ 最大的更新就是并发渲染(concurrent rendering)特性了。这里将同步渲染和并发渲染进行对比，以及了解和测试它所影响的视觉行为。
其次，使用react18，渲染方式有小的变动如下：
before
import React from &amp;#39;react&amp;#39; import ReactDOM from &amp;#39;react-dom&amp;#39; import &amp;#39;./index.css&amp;#39; import App from &amp;#39;./App&amp;#39; ReactDOM.render( &amp;lt;React.StrictMode&amp;gt; &amp;lt;App /&amp;gt; &amp;lt;/React.StrictMode&amp;gt;, document.getElementById(&amp;#39;root&amp;#39;) ) after
import { React } from &amp;#39;react&amp;#39; import { createRoot } from &amp;#39;react-dom/client&amp;#39; import &amp;#39;./index.css&amp;#39; import App from &amp;#39;./App&amp;#39; const root = createRoot(document.getElementById(&amp;#39;root&amp;#39;)) root.render(&amp;lt;App /&amp;gt;) 并发渲染 vs 同步渲染 在同步渲染过程中，每个组件所访问的外部资源都能够保证一致，因为render是一个大的任务。在这个任务完成之前，所有的任务都会被阻塞，包括页面。如果进行一个很重的渲染工作，在完成渲染之前，页面就会卡住无响应。
而并发渲染则不同，一个render可以被拆分成多个片段，在这个期间可以页面可以继续响应，不会卡死。但同时也带来了新的问题：如果某一次渲染的组件A，B访问了同一个外部资源，而这个资源在A渲染后被更改，然后B再渲染，就导致了视觉上的不一致(visual inconsistent)，不符合直觉。
例子对比 并发渲染(concurrent rendering)体现在API上就是通过startTransition来触发setter函数。
这里通过一个在页面上显示鼠标位置的实验，来更加清晰的展示这种情况。
当点击increment时，手动使页面重新渲染，然后更新页面x的值。
import { useState, useCallback, useEffect, useRef, startTransition } from &amp;#39;react&amp;#39; import &amp;#39;.</description></item><item><title>创建一个最简单的类Vue响应式数据</title><link>https://note.vaakian.com/frontend/mini-reactive-property/</link><pubDate>Fri, 25 Mar 2022 13:02:55 +0800</pubDate><guid>https://note.vaakian.com/frontend/mini-reactive-property/</guid><description>依赖管理 每个属性通过Dep类管理依赖，当属性变更，则通过Dep.notify()通知依赖项更新。
class Dep { subs = [] addSub(sub) { this.subs.push(sub) } notify() { this.subs.forEach(sub =&amp;gt; sub()) } off() { this.subs = [] } } module.exports = Dep 收集依赖 通过执行更新函数watcherFn，触发getter，此时收集到依赖函数watcherFn。依赖管理类Dep在getter中创建，如果没有依赖（即没有在watcherFn存在时触发getter），那就不会创建Dep对象，相对高效，节省资源。
处理computed属性 初始化时，执行computed函数，触发getter，收集相关依赖。 将每个computed的返回值也作为一个属性放到最终的代理属性上，并且与data同级别收集依赖。
const Dep = require(&amp;#39;./Dep&amp;#39;) // 暂存访问函数 let watcherFn // 依赖收集过程：暂存 =&amp;gt; 执行，访问属性，被收集 =&amp;gt; 清除 const watcher = (fn) =&amp;gt; { watcherFn = fn watcherFn() watcherFn = null } function Vue({ data, computed, watch }) { // 依赖管理类，每个属性key对应一个Dep对象 const deps = {} const instance = new Proxy(data, { get(target, key) { // 如果watcherFn不存在，则不是在收集依赖（不是通过watcher函数触发的），直接返回该值即可 if (watcherFn) { // 如果是watcherFn产生的get，才创建依赖。 // Warn：只有watcherFn产生的get才有意义 if (!</description></item><item><title>2022年计划</title><link>https://note.vaakian.com/daily/2022-schedule/</link><pubDate>Wed, 09 Mar 2022 22:40:25 +0800</pubDate><guid>https://note.vaakian.com/daily/2022-schedule/</guid><description>1️⃣ 继续维护XPeer 自己的小玩具，但能够从中学到非常多综合性的东西。
基于原生WebRTC封装，支持多人点对点连接。
如何创建/发布/维护一个NPM项目 如何更好的管理TypeScript项目 发布到NPM前置工作：选择性编译成js，但保留d.ts文件，即给开发者保留TS智能提示特性。 打包工具：browserify 代码职责分离 2️⃣ 保持TypeScript手感 🐝 好处不用说，需要时常练手， 每过一段时间不用，就忘掉了。
3️⃣ 持续提升英语 「大学英语四六级」已中高分飘过，
虽然当前英语水平已经可以非常流畅地·观看Youtube英文视频/Google搜索/阅读英语文档/啃生肉电影，但学无止境，如果可以 =&amp;gt; 年后考一次雅思(IELTS)。
并不是学英语本身，而是通过新的语言去了解新的「知识」和「文化」时，所带来的快感。
📖 不立太精确的目标，但保证每天学2小时。
保持全英文环境，
Mac/iPhone/iPad Google Youtube 4️⃣ 保持算法手感 前端虽然不如后端岗位那么重算法，但是一些比较常见的算法，还需有必要去掌握的。
对于前端，「树」是最重要的数据结构，所以刷算法最好偏向关于树的题。
要求不多，一个月只需要慢慢吃透5题，吃透！
资料：
Youtube-leetCode leetCode(外区) Data Structure 5️⃣ 攒钱 💰 =&amp;gt; 🗽 =&amp;gt; WLB</description></item><item><title>Implement async/await with generator/yield</title><link>https://note.vaakian.com/frontend/async-generator/</link><pubDate>Sun, 06 Mar 2022 14:11:03 +0800</pubDate><guid>https://note.vaakian.com/frontend/async-generator/</guid><description>async/await不是魔法，它只是一个语法糖，底层与生成器generator密不可分。 这里以学习为目的，简单用一个例子来模拟它们的行为，能够有一个直观的理解。
需要的前置知识，不再赘述：
ES6 async/await ES6 generator 创建一个异步加法函数 延迟1秒返回加法结果，方便实验。
function addAsync(x: number, y: number): Promise&amp;lt;number&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { setTimeout(() =&amp;gt; { resolve(x + y) }, 1000) }) } 实现单个yield（模拟await） function doAsync(g: () =&amp;gt; Generator): void { // 调用异步函数main，返回一个可迭代的iterator const it = g() // 调用next，运行到第一个yield之后暂停 const { value } = it.next() // 调用next则让yield之后的代码继续运行，并将v传递给yield作为返回值 value.then(v =&amp;gt; it.next(v)) } function* main() { const result: number = yield addAsync(5, 2) console.</description></item><item><title>Publish Ts Package</title><link>https://note.vaakian.com/frontend/publish-ts-package/</link><pubDate>Tue, 25 Jan 2022 17:37:56 +0800</pubDate><guid>https://note.vaakian.com/frontend/publish-ts-package/</guid><description> 草稿
由publish最近写的XPeer包引发的一系列新问题，记录学习所得。
XPeer是用TypeScript来写的，可以正常publish到npm上，但只能被ts项目所引用，而且需要反复编译，会浪费不少资源。
The 30-second guide to publishing a TypeScript package to NPM
预编译 tsc project 仅仅是将ts编译出原生js，前端项目能够直接import，不管是js还是ts项目。但不能通过浏览器&amp;lt;script&amp;gt;标签来引入。
browserify browserify能够对js进行bundle操作，让浏览器能够直接引入。至于什么是bundle？ tinify是browserify的压缩package，可以让bundle瘦身。 browserify-global-shim让某个包可以在windiw对象上全局访问。
配置 publish流程 npm init 配置package.json &amp;ldquo;main&amp;rdquo;: &amp;ldquo;lib/index.js&amp;rdquo;,即import的默认入口 &amp;ldquo;types&amp;rdquo;: &amp;ldquo;lib/index.d.ts&amp;rdquo;, 待考察 &amp;ldquo;exclude&amp;rdquo; &amp;ldquo;include&amp;rdquo; &amp;ldquo;declaration&amp;rdquo; 如何管理d.ts文件和types属性，让引包用户能够正常拿到type？
npm login
npm publish
使用 npm i -s xpeer
import { XPeer } from &amp;#39;xpeer&amp;#39; 总结</description></item><item><title>WebRTC: Signaling Server</title><link>https://note.vaakian.com/frontend/webrtc-signaling-server/</link><pubDate>Fri, 21 Jan 2022 21:20:40 +0800</pubDate><guid>https://note.vaakian.com/frontend/webrtc-signaling-server/</guid><description>Node.js服务端 服务端所需要做的事情：存储和广播房间信息 &amp;amp; 信令交换中介，包括sdp(SessionDescription)和ice(iceCandidate)。
接收基本的事件：join, offer, answer, icecandidate, leave
sdp用于协商会话连接方式之前的必要信息 ice协商的结果，用于候选的连接方式 客户端”仅在“join时带上id和nick，然后服务器存储该信息与Client对应。存储方式见：how to keep track of clients with WebSockets，或者直接在server.clients中挂载信息。
在offer和answer时，服务器取出对应的id和nick转发出去。
offer一定是广播，通过server.clients.forEach发送 answer是定向发送，带有receiverId，通过clientsMap发送 client对应表
class ClientsMap { constructor(server) { this.clients = new Map() server.on(&amp;#39;connection&amp;#39;, (ws, req) =&amp;gt; { ws.on(&amp;#39;message&amp;#39;, (message) =&amp;gt; { const data = JSON.parse(message) if (data.type === &amp;#39;join&amp;#39;) { this.clients.set(data.id, { id: data.id, nick: data.nick, ws: ws }) // 加入时，先注册好离开事件 ws.on(&amp;#39;close&amp;#39;, () =&amp;gt; { this.</description></item><item><title>TypeScript</title><link>https://note.vaakian.com/frontend/typescript/</link><pubDate>Fri, 21 Jan 2022 21:15:58 +0800</pubDate><guid>https://note.vaakian.com/frontend/typescript/</guid><description>动态属性 对象动态属性 即某个对象的属性类型 依赖于 另外一个属性，当Message的type为offer时，payload的属性为RTCSessionDescriptionInit，而不是一个联合类型PeerInfo | RTCSessionDescriptionInit | RTCIceCandidateInit。
interface PeerInfo { id: string nick: string } interface PayloadMap { join: PeerInfo offer: RTCSessionDescriptionInit answer: RTCSessionDescriptionInit icecandidate: RTCIceCandidateInit // leave只有单接受情况，客户端不会主动发送。 leave: PeerInfo } type Message = { [K in keyof PayloadMap]: { type: K nick: string receiverId?: string | null // playload的类型取决于type的值 payload: PayloadMap[K] } }[keyof PayloadMap] 单拎出来这一段，其实是map出了多个类型，一个key对应一个类型。然后Message通过keyof PayloadMap来获取到一个联合类型。
const MessageTypeMap = { [K in keyof PayloadMap]: { type: K nick: string id: string receiverId?</description></item><item><title>WebRTC: Multi-RTCPeerCoonection</title><link>https://note.vaakian.com/frontend/multi-rtcpeercoonection/</link><pubDate>Fri, 21 Jan 2022 16:24:57 +0800</pubDate><guid>https://note.vaakian.com/frontend/multi-rtcpeercoonection/</guid><description>一）抛出问题 一个RTCPeerConnection只能对应另外一个RTCPeerCoonection，如果想要实现多人会议。那么需要统一管理多个RTCPeerConnection，任何本地数据都要广播到多个RTCPeerConnection中去。
二）职责分割 在通过纯原生的RTCPeerConnection实现双人一对一视频会议时，发现代码分隔时已经力不从心了。如何实现多人更需要一些明确的职责分割。
管理多个PeerConnection 将本地数据广播到多个PeerConnection *如何将PeerConnection与WebSocket中的Client绑定（如何识别身份） Track概念：管理多个Track到一个Stream中 本地Stream推到远程 2.1 如何识别身份 如何在WebSocket和PeerConnection建立连接过程中去确定身份，如何确定两者相关联？
首先要理清楚，建立连接的整个流程。然后找出应该在哪个阶段去进行身份确认。
加入房间，发送JoinRoom消息，带上自己的nick和id（唯一标识），服务器存储信息对应，回复房间Clients列表。 如果房间有人，发送Offer消息（带nick和id），服务器广播之后，其他人回复Answer消息（带个人信息和将要发往的id） 前端接收到Answer，将对应的PeerConnection与该id和nick对应。此后的连接就容易对应了。 peerConnection.createOffer() // 1. 创建offer .then(offer =&amp;gt; { return peerConnection.setLocalDescription(offer); }) .then(() =&amp;gt; { // 2. 发送offer（广播） return ws.send(JSON.stringify({ type: &amp;#39;offer&amp;#39;, nick: nick, id: id, sdp: peerConnection.localDescription })); }) .then(() =&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { // 3. 接收answer ws.onmessage = (event) =&amp;gt; { const data = JSON.</description></item><item><title>Nadine Hwang</title><link>https://note.vaakian.com/daily/nadine-hwang/</link><pubDate>Wed, 19 Jan 2022 21:56:34 +0800</pubDate><guid>https://note.vaakian.com/daily/nadine-hwang/</guid><description>记录传奇人物——Nadine Hwang相关的信息，一个被历史掩埋的中国女人。
相关资料：
Nadine Hwang ‘China Hwang’ of the Nazi camp for women 寻找Nadine Hwang，一个在二战纪录片中露出不屑表情的中国女人</description></item><item><title>React Hooks</title><link>https://note.vaakian.com/frontend/react-hooks/</link><pubDate>Tue, 18 Jan 2022 14:47:17 +0800</pubDate><guid>https://note.vaakian.com/frontend/react-hooks/</guid><description>[TOC]
useMemo 千万不要把useMemo和React.memo混为一谈，两者都是根据依赖变化来缓存数据的。useMemo(fn, deps)参照第二个参数列表的变化返回新的数据，否则返回缓存的数据。而React.memo只会在组件的props变化时重新渲染该组件。
使用场景 有非常耗时的计算，比如以下例子中的expensiveComputation，每一次组件渲染，都会调用该函数，并且重新计算。但其实a和b并没有变化时，计算的值都是一样的，所以需要使用到useMemo将结果缓存下来，而无需重新计算。
function App() { const [a, setA] = useState(1) const [b, setB] = useState(2) // const value = expensiveComputation(a, b) const value = useMemo(() =&amp;gt; expensiveComputation(a, b), [a, b]) return &amp;lt;div&amp;gt;result: {value}&amp;lt;/div&amp;gt; }
- 任何**hook**的依赖为对象时，可能会遇到「字面上」相同，但不是同一个对象，所以会导致依赖判断错误。因为**hook**的依赖数组对比是浅层的对比，也就是 `===` 对比。因为每次渲染时，组件内的所有字面变量都会被重新创建，所以遇到对象应该要格外注意。 &amp;gt; 对象判定相等 ```js const obj = {count: 1} console.log(obj === obj) // true // 引用不一样，所以为false console.log({count: 1} === {count: 1}) // false 以下例子，effect中的依赖是对象，虽然a, b没有发生变化，obj的字面上看起来也没用变化。但是在每次渲染时，都会创建一个新的对象，该对象引用不一样，所以每次都会执行effect。</description></item><item><title>WebRTC: RTCPeerConncetion</title><link>https://note.vaakian.com/frontend/webrtc-connection/</link><pubDate>Sat, 15 Jan 2022 13:29:47 +0800</pubDate><guid>https://note.vaakian.com/frontend/webrtc-connection/</guid><description>论文草稿
what is WebRTC WebRTC(Web Real-Time Communication)是一个最先由Google发布的点对点（Peer-to-Peer）通信协议，目前已经被各大浏览器所内置，早期不同浏览器的API有细微差别，需要开发者手动做兼容。现在可以使用MDN所推荐的WebRTC adapter.js来解决兼容问题。
其次它不仅仅适用于浏览器，也可以在任何其它不同平台的应用程序中使用，只要符合WebRTC的规范即可。
信道建立流程 两个实体（Peer）要建立连接或者说信道之前，需要先进行一项最最重要的工作，即信令交换。它将两个实体的信息（包含IP地址、端口等等各种用于建立连接的必要信息）进行互相交换，双方拿到信息后建立独立的信道。此后，两个实体就可以通过信道进行通信了，无需再通过服务器进行数据传输。
两种通信方式的优缺点 点对点通信方式不同于传统的中心化通信方式，需要一台或者多台服务器进行数据转发或者存储，这样会导致服务器的带宽和计算压力增大，而当服务器的负载增加时，会进而导致整个系统的稳定性下降，一旦中心服务器宕机，所有用户的通信将全部中断。而如果采用点对点通信方式，省去了服务器中转存储环节，降低了各个实体之间依赖性。用户之间可以直接通过网络进行通信，某个实体中断仅仅影响它自身，这样既可以节省服务器的资源，又提高了系统的稳定性。
不过，点对点通信也有自身的缺点，由于视频会议属于多对多的连接，每个实体要和其它所有实体都建立连接，随着系统中实体的增加，单个实体的压力也会随之增加。而采用的中心服务器转发存储方式就不会出现这种问题， 每个实体只需要和中心服务器建立连接，中心服务器负责存储数据和转发数据到其它实体。
所以，在实体较少、传输数据量大、网络延迟要求更高的场景下，点对点通信方式比较适合，反之，中心服务器转发存储方式比较适合。
RTCPeerConnection RTCPeerConnection负责很多事情，包括：
信令处理（singal processing） 编解码（Codec handling） 点对点连接（P2P connection） 安全（Security） 流量控制（bandwidth management） …… RTC创建连接过程主要是通过一个信令服务器进行SDP信息交换，这个过程可以通过WebSocket进行，也可以通过HTTP进行，当然WebSocket最佳。
const conn = new SomeWebsocketConn() const pc = new RTCPeerConnection(null) function sendOffer(desc) { // 发送offer到服务器上 conn.send({type: &amp;#39;offer&amp;#39;, sdp: desc}) // .then(gotAnswer) } // 当成功创建offer时调用 pc.createOffer(gotOffer) function gotOffer(desc) { pc.setLocalDescription(desc) // 发送到服务器 sendOffer(desc) } // 当服务器返回answer时调用 conn.</description></item><item><title>《送别》</title><link>https://note.vaakian.com/daily/songbie/</link><pubDate>Fri, 14 Jan 2022 23:05:06 +0800</pubDate><guid>https://note.vaakian.com/daily/songbie/</guid><description>长亭外，古道边，芳草碧连天。晚风拂柳笛声残，夕阳山外山。
天之涯，地之角，知交半零落。一壶浊酒尽余欢，今宵别梦寒。
长亭外，古道边，芳草碧连天。问君此去几时来，来时莫徘徊。
天之涯，地之角，知交半零落。人生难得是欢聚，惟有别离多。</description></item><item><title>Vue响应式原理</title><link>https://note.vaakian.com/frontend/vue-reactive/</link><pubDate>Fri, 14 Jan 2022 21:22:48 +0800</pubDate><guid>https://note.vaakian.com/frontend/vue-reactive/</guid><description>开始 众所周知，Vue的响应式实现方式有两种，在Vue2中通过「Object.defineProperty」重新定义属性的descriptor中的getter/setter实现来。而Vue3通过ES6的“新人”「Proxy」来实现。
Vue2：Object.defineProperty 网传：&amp;ldquo;Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；&amp;rdquo;
纠错： 为什么Vue2中不劫持数组？
数组的位置不固定，数量多变，正常对象key对应value一般不会变，但是如果数组删除了某个元素，比如第一个元素被删除或者头部增加一个元素，那么将导致后面所有的key对应value错位，如果6个元素，也就会触发5次set。
数组元素可能非常非常多，每个元素进行劫持有一定浪费，这可能是Evan you对性能的考虑。
Vue2将数组的7个变异方法进行了重写，也就是更改了Array原型上的方法达到劫持变化。
Vue2将对象新增属性/数组修改等操作，通过Vue.set来统一实现，这样其实是直接告诉Vue自己的set行为，即要新增/修改的属性名，然后重新劫持或者通知修改Deps[key].notify()，Vue2才可以监测到「新增数据/数组下标」的变化。
以下代码测试拦截数组会发生的情况
const arr = [1, 2, 3, 4, 5, 6] for (let key in arr) { let value = arr[key] Object.defineProperty(arr, key, { get() { console.log(`get: ${key}`) return value }, set(newValue) { console.log(`set: ${key}to ${newValue}`) return value = newValue } }) } arr[0] = 999 // 打印：set：0 to 999 arr[3] // 打印：get：3 arr.</description></item><item><title>React之：自定义hooks: useCamera</title><link>https://note.vaakian.com/frontend/usecamera/</link><pubDate>Tue, 14 Dec 2021 15:55:03 +0800</pubDate><guid>https://note.vaakian.com/frontend/usecamera/</guid><description>⚠️注：从老博客迁移，可能有排版问题。
尝试用浏览器API封装一个读取摄像头视频流的useCamera自定义hooks，一步一步优化，总结一下得到目前为止的最佳实践。 首先，摄像头读取API需要传入最基本的参数constraints，通过promise方式得到stream后会展示到video标签上，那么useCamera应该接受一个能够读取到video标签的参数，那么首选ref，得到如下第一版代码：
function useCamera(constraints, videoRef) { const storedStream = useRef(null) // 当stream改变时，创建新的stop函数 const stop = useCallback(() =&amp;gt; { storedStream.current.getTracks().forEach(track =&amp;gt; track.stop()) }, [storedStream.current]) // 当constraints/videoRef改变时，创建新的start函数 const start = useCallback(() =&amp;gt; { navigator.mediaDevices.getUserMedia(constraints) .then(stream =&amp;gt; { console.log(&amp;#39;setting stream&amp;#39;) videoRef.current.srcObject = stream storedStreamRef.current = stream }) .catch(err =&amp;gt; { console.error(err) }) }, [constraints, videoRef]) // constraints改变时，stop上一次的媒体流并重新请求 useEffect(() =&amp;gt; { start() return stop }, [constraints]) return [start, stop] } 然后在组件中调用创建的hooks，功能上运行正常。</description></item><item><title>Introduction</title><link>https://note.vaakian.com/about/</link><pubDate>Tue, 14 Jan 2020 20:09:20 +0800</pubDate><guid>https://note.vaakian.com/about/</guid><description>主前端，不过其它的也都有接触，
对网络安全感兴趣，算是一名(业余)脚本小子。
2022本科应届生，侥幸入职某互联网大厂。</description></item><item><title>Introduction</title><link>https://note.vaakian.com/frontend/introduction/</link><pubDate>Tue, 14 Jan 2020 20:09:20 +0800</pubDate><guid>https://note.vaakian.com/frontend/introduction/</guid><description>Getting Started 从很久很久以前就想记录下来日常的学习笔记（不是博客），但都无疾而终。从wordpress=&amp;gt;Notion=&amp;gt;github issue都感觉差点味道。
而之前感觉通过hexo or hugo这种编译型的静态部署来记录又太麻烦，但现在需要它们的可定制性，索性还是尝试用hugo来继续记录吧。
Why not hexo? written in Go, which it&amp;rsquo;s fast.
About me 主前端，不过其它的也都有接触， 对网络安全感兴趣，算是一名业余脚本小子， 2022本科应届生，即将入职某互联网大厂。</description></item></channel></rss>