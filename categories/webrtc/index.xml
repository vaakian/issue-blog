<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WebRTC on Study Notes</title><link>https://notes.vaakian.com/categories/webrtc/</link><description>Recent content in WebRTC on Study Notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 21 Jan 2022 21:20:40 +0800</lastBuildDate><atom:link href="https://notes.vaakian.com/categories/webrtc/index.xml" rel="self" type="application/rss+xml"/><item><title>WebRTC: Signaling Server</title><link>https://notes.vaakian.com/frontend/webrtc-signaling-server/</link><pubDate>Fri, 21 Jan 2022 21:20:40 +0800</pubDate><guid>https://notes.vaakian.com/frontend/webrtc-signaling-server/</guid><description>Node.js服务端 服务端所需要做的事情：存储和广播房间信息 &amp;amp; 信令交换中介，包括sdp(SessionDescription)和ice(iceCandidate)。
接收基本的事件：join, offer, answer, icecandidate, leave
sdp用于协商会话连接方式之前的必要信息 ice协商的结果，用于候选的连接方式 客户端”仅在“join时带上id和nick，然后服务器存储该信息与Client对应。存储方式见：how to keep track of clients with WebSockets，或者直接在server.clients中挂载信息。
在offer和answer时，服务器取出对应的id和nick转发出去。
offer一定是广播，通过server.clients.forEach发送 answer是定向发送，带有receiverId，通过clientsMap发送 client对应表
class ClientsMap { constructor(server) { this.clients = new Map() server.on(&amp;#39;connection&amp;#39;, (ws, req) =&amp;gt; { ws.on(&amp;#39;message&amp;#39;, (message) =&amp;gt; { const data = JSON.parse(message) if (data.type === &amp;#39;join&amp;#39;) { this.clients.set(data.id, { id: data.id, nick: data.nick, ws: ws }) // 加入时，先注册好离开事件 ws.on(&amp;#39;close&amp;#39;, () =&amp;gt; { this.</description></item><item><title>WebRTC: Multi-RTCPeerCoonection</title><link>https://notes.vaakian.com/frontend/multi-rtcpeercoonection/</link><pubDate>Fri, 21 Jan 2022 16:24:57 +0800</pubDate><guid>https://notes.vaakian.com/frontend/multi-rtcpeercoonection/</guid><description>一）抛出问题 一个RTCPeerConnection只能对应另外一个RTCPeerCoonection，如果想要实现多人会议。那么需要统一管理多个RTCPeerConnection，任何本地数据都要广播到多个RTCPeerConnection中去。
二）职责分割 在通过纯原生的RTCPeerConnection实现双人一对一视频会议时，发现代码分隔时已经力不从心了。如何实现多人更需要一些明确的职责分割。
管理多个PeerConnection 将本地数据广播到多个PeerConnection *如何将PeerConnection与WebSocket中的Client绑定（如何识别身份） Track概念：管理多个Track到一个Stream中 本地Stream推到远程 2.1 如何识别身份 如何在WebSocket和PeerConnection建立连接过程中去确定身份，如何确定两者相关联？
首先要理清楚，建立连接的整个流程。然后找出应该在哪个阶段去进行身份确认。
加入房间，发送JoinRoom消息，带上自己的nick和id（唯一标识），服务器存储信息对应，回复房间Clients列表。 如果房间有人，发送Offer消息（带nick和id），服务器广播之后，其他人回复Answer消息（带个人信息和将要发往的id） 前端接收到Answer，将对应的PeerConnection与该id和nick对应。此后的连接就容易对应了。 peerConnection.createOffer() // 1. 创建offer .then(offer =&amp;gt; { return peerConnection.setLocalDescription(offer); }) .then(() =&amp;gt; { // 2. 发送offer（广播） return ws.send(JSON.stringify({ type: &amp;#39;offer&amp;#39;, nick: nick, id: id, sdp: peerConnection.localDescription })); }) .then(() =&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { // 3. 接收answer ws.onmessage = (event) =&amp;gt; { const data = JSON.</description></item><item><title>WebRTC: RTCPeerConncetion</title><link>https://notes.vaakian.com/frontend/webrtc-connection/</link><pubDate>Sat, 15 Jan 2022 13:29:47 +0800</pubDate><guid>https://notes.vaakian.com/frontend/webrtc-connection/</guid><description>论文草稿
what is WebRTC WebRTC(Web Real-Time Communication)是一个最先由Google发布的点对点（Peer-to-Peer）通信协议，目前已经被各大浏览器所内置，早期不同浏览器的API有细微差别，需要开发者手动做兼容。现在可以使用MDN所推荐的WebRTC adapter.js来解决兼容问题。
其次它不仅仅适用于浏览器，也可以在任何其它不同平台的应用程序中使用，只要符合WebRTC的规范即可。
信道建立流程 两个实体（Peer）要建立连接或者说信道之前，需要先进行一项最最重要的工作，即信令交换。它将两个实体的信息（包含IP地址、端口等等各种用于建立连接的必要信息）进行互相交换，双方拿到信息后建立独立的信道。此后，两个实体就可以通过信道进行通信了，无需再通过服务器进行数据传输。
两种通信方式的优缺点 点对点通信方式不同于传统的中心化通信方式，需要一台或者多台服务器进行数据转发或者存储，这样会导致服务器的带宽和计算压力增大，而当服务器的负载增加时，会进而导致整个系统的稳定性下降，一旦中心服务器宕机，所有用户的通信将全部中断。而如果采用点对点通信方式，省去了服务器中转存储环节，降低了各个实体之间依赖性。用户之间可以直接通过网络进行通信，某个实体中断仅仅影响它自身，这样既可以节省服务器的资源，又提高了系统的稳定性。
不过，点对点通信也有自身的缺点，由于视频会议属于多对多的连接，每个实体要和其它所有实体都建立连接，随着系统中实体的增加，单个实体的压力也会随之增加。而采用的中心服务器转发存储方式就不会出现这种问题， 每个实体只需要和中心服务器建立连接，中心服务器负责存储数据和转发数据到其它实体。
所以，在实体较少、传输数据量大、网络延迟要求更高的场景下，点对点通信方式比较适合，反之，中心服务器转发存储方式比较适合。
RTCPeerConnection RTCPeerConnection负责很多事情，包括：
信令处理（singal processing） 编解码（Codec handling） 点对点连接（P2P connection） 安全（Security） 流量控制（bandwidth management） …… RTC创建连接过程主要是通过一个信令服务器进行SDP信息交换，这个过程可以通过WebSocket进行，也可以通过HTTP进行，当然WebSocket最佳。
const conn = new SomeWebsocketConn() const pc = new RTCPeerConnection(null) function sendOffer(desc) { // 发送offer到服务器上 conn.send({type: &amp;#39;offer&amp;#39;, sdp: desc}) // .then(gotAnswer) } // 当成功创建offer时调用 pc.createOffer(gotOffer) function gotOffer(desc) { pc.setLocalDescription(desc) // 发送到服务器 sendOffer(desc) } // 当服务器返回answer时调用 conn.</description></item></channel></rss>