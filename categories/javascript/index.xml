<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JavaScript on Study Notes</title><link>https://note.vaakian.com/categories/javascript/</link><description>Recent content in JavaScript on Study Notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 19 Apr 2022 15:48:02 +0800</lastBuildDate><atom:link href="https://note.vaakian.com/categories/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>Creating a Function and it's prototype</title><link>https://note.vaakian.com/frontend/prototype/</link><pubDate>Tue, 19 Apr 2022 15:48:02 +0800</pubDate><guid>https://note.vaakian.com/frontend/prototype/</guid><description>简单回顾 prototype prototype 可以作为实例之间共享数据的一块空间。所以往 prototype 上放置任何属性，都可以被所有实例访问到。
function Animal() { // this是实例本身 console.log(this.name); } Animal.prototype.name = &amp;#39;Animal&amp;#39;; Animal.prototype.greet = function () { console.log(`hello, i am ${this.name}`); }; const cat = new Animal(); const dog = new Animal(); (cat.__proto__ === Animal.prototype) === dog.__proto__; 当通过实例本身访问任何属性，其过程为：自身 =&amp;gt; __proto__ =&amp;gt; __proto__ 的 __proto__ =&amp;gt; null
所以
const dog = new Animal(); // 相等 (dog.greet === Animal.prototype.greet) === dog.__proto__.greet; 但如果将构造函数改为
function Animal() { this.greet = function () { console.</description></item><item><title>Implement async/await with generator/yield</title><link>https://note.vaakian.com/frontend/async-generator/</link><pubDate>Sun, 06 Mar 2022 14:11:03 +0800</pubDate><guid>https://note.vaakian.com/frontend/async-generator/</guid><description>async/await不是魔法，它只是一个语法糖，底层与生成器generator密不可分。 这里以学习为目的，简单用一个例子来模拟它们的行为，能够有一个直观的理解。
需要的前置知识，不再赘述：
ES6 async/await ES6 generator 创建一个异步加法函数 延迟1秒返回加法结果，方便实验。
function addAsync(x: number, y: number): Promise&amp;lt;number&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { setTimeout(() =&amp;gt; { resolve(x + y) }, 1000) }) } 实现单个yield（模拟await） function doAsync(g: () =&amp;gt; Generator): void { // 调用异步函数main，返回一个可迭代的iterator const it = g() // 调用next，运行到第一个yield之后暂停 const { value } = it.next() // 调用next则让yield之后的代码继续运行，并将v传递给yield作为返回值 value.then(v =&amp;gt; it.next(v)) } function* main() { const result: number = yield addAsync(5, 2) console.</description></item><item><title>React Hooks</title><link>https://note.vaakian.com/frontend/react-hooks/</link><pubDate>Tue, 18 Jan 2022 14:47:17 +0800</pubDate><guid>https://note.vaakian.com/frontend/react-hooks/</guid><description>[TOC]
useMemo 千万不要把useMemo和React.memo混为一谈，两者都是根据依赖变化来缓存数据的。useMemo(fn, deps)参照第二个参数列表的变化返回新的数据，否则返回缓存的数据。而React.memo只会在组件的props变化时重新渲染该组件。
使用场景 有非常耗时的计算，比如以下例子中的expensiveComputation，每一次组件渲染，都会调用该函数，并且重新计算。但其实a和b并没有变化时，计算的值都是一样的，所以需要使用到useMemo将结果缓存下来，而无需重新计算。
function App() { const [a, setA] = useState(1) const [b, setB] = useState(2) // const value = expensiveComputation(a, b) const value = useMemo(() =&amp;gt; expensiveComputation(a, b), [a, b]) return &amp;lt;div&amp;gt;result: {value}&amp;lt;/div&amp;gt; }
- 任何**hook**的依赖为对象时，可能会遇到「字面上」相同，但不是同一个对象，所以会导致依赖判断错误。因为**hook**的依赖数组对比是浅层的对比，也就是 `===` 对比。因为每次渲染时，组件内的所有字面变量都会被重新创建，所以遇到对象应该要格外注意。 &amp;gt; 对象判定相等 ```js const obj = {count: 1} console.log(obj === obj) // true // 引用不一样，所以为false console.log({count: 1} === {count: 1}) // false 以下例子，effect中的依赖是对象，虽然a, b没有发生变化，obj的字面上看起来也没用变化。但是在每次渲染时，都会创建一个新的对象，该对象引用不一样，所以每次都会执行effect。</description></item><item><title>Vue响应式原理</title><link>https://note.vaakian.com/frontend/vue-reactive/</link><pubDate>Fri, 14 Jan 2022 21:22:48 +0800</pubDate><guid>https://note.vaakian.com/frontend/vue-reactive/</guid><description>开始 众所周知，Vue的响应式实现方式有两种，在Vue2中通过「Object.defineProperty」重新定义属性的descriptor中的getter/setter实现来。而Vue3通过ES6的“新人”「Proxy」来实现。
Vue2：Object.defineProperty 网传：&amp;ldquo;Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；&amp;rdquo;
纠错： 为什么Vue2中不劫持数组？
数组的位置不固定，数量多变，正常对象key对应value一般不会变，但是如果数组删除了某个元素，比如第一个元素被删除或者头部增加一个元素，那么将导致后面所有的key对应value错位，如果6个元素，也就会触发5次set。
数组元素可能非常非常多，每个元素进行劫持有一定浪费，这可能是Evan you对性能的考虑。
Vue2将数组的7个变异方法进行了重写，也就是更改了Array原型上的方法达到劫持变化。
Vue2将对象新增属性/数组修改等操作，通过Vue.set来统一实现，这样其实是直接告诉Vue自己的set行为，即要新增/修改的属性名，然后重新劫持或者通知修改Deps[key].notify()，Vue2才可以监测到「新增数据/数组下标」的变化。
以下代码测试拦截数组会发生的情况
const arr = [1, 2, 3, 4, 5, 6] for (let key in arr) { let value = arr[key] Object.defineProperty(arr, key, { get() { console.log(`get: ${key}`) return value }, set(newValue) { console.log(`set: ${key}to ${newValue}`) return value = newValue } }) } arr[0] = 999 // 打印：set：0 to 999 arr[3] // 打印：get：3 arr.</description></item></channel></rss>