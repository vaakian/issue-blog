<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Vue on Study Notes</title><link>https://note.vaakian.com/categories/vue/</link><description>Recent content in Vue on Study Notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 25 Mar 2022 13:02:55 +0800</lastBuildDate><atom:link href="https://note.vaakian.com/categories/vue/index.xml" rel="self" type="application/rss+xml"/><item><title>创建一个最简单的类Vue响应式数据</title><link>https://note.vaakian.com/frontend/mini-reactive-property/</link><pubDate>Fri, 25 Mar 2022 13:02:55 +0800</pubDate><guid>https://note.vaakian.com/frontend/mini-reactive-property/</guid><description>依赖管理 每个属性通过Dep类管理依赖，当属性变更，则通过Dep.notify()通知依赖项更新。
class Dep { subs = [] addSub(sub) { this.subs.push(sub) } notify() { this.subs.forEach(sub =&amp;gt; sub()) } off() { this.subs = [] } } module.exports = Dep 收集依赖 通过执行更新函数watcherFn，触发getter，此时收集到依赖函数watcherFn。依赖管理类Dep在getter中创建，如果没有依赖（即没有在watcherFn存在时触发getter），那就不会创建Dep对象，相对高效，节省资源。
处理computed属性 初始化时，执行computed函数，触发getter，收集相关依赖。 将每个computed的返回值也作为一个属性放到最终的代理属性上，并且与data同级别收集依赖。
const Dep = require(&amp;#39;./Dep&amp;#39;) // 暂存访问函数 let watcherFn // 依赖收集过程：暂存 =&amp;gt; 执行，访问属性，被收集 =&amp;gt; 清除 const watcher = (fn) =&amp;gt; { watcherFn = fn watcherFn() watcherFn = null } function Vue({ data, computed, watch }) { // 依赖管理类，每个属性key对应一个Dep对象 const deps = {} const instance = new Proxy(data, { get(target, key) { // 如果watcherFn不存在，则不是在收集依赖（不是通过watcher函数触发的），直接返回该值即可 if (watcherFn) { // 如果是watcherFn产生的get，才创建依赖。 // Warn：只有watcherFn产生的get才有意义 if (!</description></item></channel></rss>