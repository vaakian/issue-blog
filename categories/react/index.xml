<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>React on Study Notes</title><link>https://note.vaakian.com/categories/react/</link><description>Recent content in React on Study Notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 12 Apr 2022 14:56:18 +0800</lastBuildDate><atom:link href="https://note.vaakian.com/categories/react/index.xml" rel="self" type="application/rss+xml"/><item><title>React18 updates</title><link>https://note.vaakian.com/frontend/react18/</link><pubDate>Tue, 12 Apr 2022 14:56:18 +0800</pubDate><guid>https://note.vaakian.com/frontend/react18/</guid><description>React18更新了什么？ 最大的更新就是并发渲染(concurrent rendering)特性了。这里将同步渲染和并发渲染进行对比，以及了解和测试它所影响的视觉行为。
其次，使用react18，渲染方式有小的变动如下：
before
import React from &amp;#39;react&amp;#39; import ReactDOM from &amp;#39;react-dom&amp;#39; import &amp;#39;./index.css&amp;#39; import App from &amp;#39;./App&amp;#39; ReactDOM.render( &amp;lt;React.StrictMode&amp;gt; &amp;lt;App /&amp;gt; &amp;lt;/React.StrictMode&amp;gt;, document.getElementById(&amp;#39;root&amp;#39;) ) after
import { React } from &amp;#39;react&amp;#39; import { createRoot } from &amp;#39;react-dom/client&amp;#39; import &amp;#39;./index.css&amp;#39; import App from &amp;#39;./App&amp;#39; const root = createRoot(document.getElementById(&amp;#39;root&amp;#39;)) root.render(&amp;lt;App /&amp;gt;) 并发渲染 vs 同步渲染 在同步渲染过程中，每个组件所访问的外部资源都能够保证一致，因为render是一个大的任务。在这个任务完成之前，所有的任务都会被阻塞，包括页面。如果进行一个很重的渲染工作，在完成渲染之前，页面就会卡住无响应。
而并发渲染则不同，一个render可以被拆分成多个片段，在这个期间可以页面可以继续响应，不会卡死。但同时也带来了新的问题：如果某一次渲染的组件A，B访问了同一个外部资源，而这个资源在A渲染后被更改，然后B再渲染，就导致了视觉上的不一致(visual inconsistent)，不符合直觉。
例子对比 并发渲染(concurrent rendering)体现在API上就是通过startTransition来触发setter函数。
这里通过一个在页面上显示鼠标位置的实验，来更加清晰的展示这种情况。
当点击increment时，手动使页面重新渲染，然后更新页面x的值。
import { useState, useCallback, useEffect, useRef, startTransition } from &amp;#39;react&amp;#39; import &amp;#39;.</description></item><item><title>React Hooks</title><link>https://note.vaakian.com/frontend/react-hooks/</link><pubDate>Tue, 18 Jan 2022 14:47:17 +0800</pubDate><guid>https://note.vaakian.com/frontend/react-hooks/</guid><description>[TOC]
useMemo 千万不要把useMemo和React.memo混为一谈，两者都是根据依赖变化来缓存数据的。useMemo(fn, deps)参照第二个参数列表的变化返回新的数据，否则返回缓存的数据。而React.memo只会在组件的props变化时重新渲染该组件。
使用场景 有非常耗时的计算，比如以下例子中的expensiveComputation，每一次组件渲染，都会调用该函数，并且重新计算。但其实a和b并没有变化时，计算的值都是一样的，所以需要使用到useMemo将结果缓存下来，而无需重新计算。 function App() { const [a, setA] = useState(1) const [b, setB] = useState(2) // const value = expensiveComputation(a, b) const value = useMemo(() =&amp;gt; expensiveComputation(a, b), [a, b]) return &amp;lt;div&amp;gt;result: {value}&amp;lt;/div&amp;gt; } 任何hook的依赖为对象时，可能会遇到「字面上」相同，但不是同一个对象，所以会导致依赖判断错误。因为hook的依赖数组对比是浅层的对比，也就是 === 对比。因为每次渲染时，组件内的所有字面变量都会被重新创建，所以遇到对象应该要格外注意。 对象判定相等
const obj = {count: 1} console.log(obj === obj) // true // 引用不一样，所以为false console.log({count: 1} === {count: 1}) // false 以下例子，effect中的依赖是对象，虽然a, b没有发生变化，obj的字面上看起来也没用变化。但是在每次渲染时，都会创建一个新的对象，该对象引用不一样，所以每次都会执行effect。</description></item><item><title>React之：自定义hooks: useCamera</title><link>https://note.vaakian.com/frontend/usecamera/</link><pubDate>Tue, 14 Dec 2021 15:55:03 +0800</pubDate><guid>https://note.vaakian.com/frontend/usecamera/</guid><description>⚠️注：从老博客迁移，可能有排版问题。
尝试用浏览器API封装一个读取摄像头视频流的useCamera自定义hooks，一步一步优化，总结一下得到目前为止的最佳实践。 首先，摄像头读取API需要传入最基本的参数constraints，通过promise方式得到stream后会展示到video标签上，那么useCamera应该接受一个能够读取到video标签的参数，那么首选ref，得到如下第一版代码：
function useCamera(constraints, videoRef) { const storedStream = useRef(null) // 当stream改变时，创建新的stop函数 const stop = useCallback(() =&amp;gt; { storedStream.current.getTracks().forEach(track =&amp;gt; track.stop()) }, [storedStream.current]) // 当constraints/videoRef改变时，创建新的start函数 const start = useCallback(() =&amp;gt; { navigator.mediaDevices.getUserMedia(constraints) .then(stream =&amp;gt; { console.log(&amp;#39;setting stream&amp;#39;) videoRef.current.srcObject = stream storedStreamRef.current = stream }) .catch(err =&amp;gt; { console.error(err) }) }, [constraints, videoRef]) // constraints改变时，stop上一次的媒体流并重新请求 useEffect(() =&amp;gt; { start() return stop }, [constraints]) return [start, stop] } 然后在组件中调用创建的hooks，功能上运行正常。</description></item></channel></rss>