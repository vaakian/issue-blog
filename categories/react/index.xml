<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>React on Study Notes</title><link>https://notes.vaakian.com/categories/react/</link><description>Recent content in React on Study Notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 18 Jan 2022 14:47:17 +0800</lastBuildDate><atom:link href="https://notes.vaakian.com/categories/react/index.xml" rel="self" type="application/rss+xml"/><item><title>React Hooks</title><link>https://notes.vaakian.com/frontend/react-hooks/</link><pubDate>Tue, 18 Jan 2022 14:47:17 +0800</pubDate><guid>https://notes.vaakian.com/frontend/react-hooks/</guid><description>[TOC]
useMemo 千万不要把useMemo和React.memo混为一谈，两者都是根据依赖变化来缓存数据的。useMemo(fn, deps)参照第二个参数列表的变化返回新的数据，否则返回缓存的数据。而React.memo只会在组件的props变化时重新渲染该组件。
使用场景 有非常耗时的计算，比如以下例子中的expensiveComputation，每一次组件渲染，都会调用该函数，并且重新计算。但其实a和b并没有变化时，计算的值都是一样的，所以需要使用到useMemo将结果缓存下来，而无需重新计算。 function App() { const [a, setA] = useState(1) const [b, setB] = useState(2) // const value = expensiveComputation(a, b) const value = useMemo(() =&amp;gt; expensiveComputation(a, b), [a, b]) return &amp;lt;div&amp;gt;result: {value}&amp;lt;/div&amp;gt; } 任何hook的依赖为对象时，可能会遇到「字面上」相同，但不是同一个对象，所以会导致依赖判断错误。因为hook的依赖数组对比是浅层的对比，也就是 === 对比。因为每次渲染时，组件内的所有字面变量都会被重新创建，所以遇到对象应该要格外注意。 对象判定相等
const obj = {count: 1} console.log(obj === obj) // true // 引用不一样，所以为false console.log({count: 1} === {count: 1}) // false 以下例子，effect中的依赖是对象，虽然a, b没有发生变化，obj的字面上看起来也没用变化。但是在每次渲染时，都会创建一个新的对象，该对象引用不一样，所以每次都会执行effect。</description></item><item><title>React之：自定义hooks: useCamera</title><link>https://notes.vaakian.com/frontend/usecamera/</link><pubDate>Tue, 14 Dec 2021 15:55:03 +0800</pubDate><guid>https://notes.vaakian.com/frontend/usecamera/</guid><description>尝试用浏览器API封装一个读取摄像头视频流的useCamera自定义hooks，一步一步优化，总结一下得到目前为止的最佳实践。 首先，摄像头读取API需要传入最基本的参数constraints，通过promise方式得到stream后会展示到video标签上，那么useCamera应该接受一个能够读取到video标签的参数，那么首选ref，得到如下第一版代码：
function useCamera(constraints, videoRef) { const storedStream = useRef(null) // 当stream改变时，创建新的stop函数 const stop = useCallback(() =&amp;gt; { storedStream.current.getTracks().forEach(track =&amp;gt; track.stop()) }, [storedStream.current]) // 当constraints/videoRef改变时，创建新的start函数 const start = useCallback(() =&amp;gt; { navigator.mediaDevices.getUserMedia(constraints) .then(stream =&amp;gt; { console.log(&amp;#39;setting stream&amp;#39;) videoRef.current.srcObject = stream storedStreamRef.current = stream }) .catch(err =&amp;gt; { console.error(err) }) }, [constraints, videoRef]) // constraints改变时，stop上一次的媒体流并重新请求 useEffect(() =&amp;gt; { start() return stop }, [constraints]) return [start, stop] } 然后在组件中调用创建的hooks，功能上运行正常。</description></item></channel></rss>