<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TypeScript on Study Notes</title><link>https://notes.vaakian.com/categories/typescript/</link><description>Recent content in TypeScript on Study Notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 21 Jan 2022 21:15:58 +0800</lastBuildDate><atom:link href="https://notes.vaakian.com/categories/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title>Typescript</title><link>https://notes.vaakian.com/frontend/typescript/</link><pubDate>Fri, 21 Jan 2022 21:15:58 +0800</pubDate><guid>https://notes.vaakian.com/frontend/typescript/</guid><description>动态属性 对象动态属性 即某个对象的属性类型 依赖于 另外一个属性，当Message的type为offer时，payload的属性为RTCSessionDescriptionInit，而不是一个联合类型PeerInfo | RTCSessionDescriptionInit | RTCIceCandidateInit。
interface PeerInfo { id: string nick: string } interface PayloadMap { join: PeerInfo offer: RTCSessionDescriptionInit answer: RTCSessionDescriptionInit icecandidate: RTCIceCandidateInit // leave只有单接受情况，客户端不会主动发送。 leave: PeerInfo } type Message = { [K in keyof PayloadMap]: { type: K nick: string receiverId?: string | null // playload的类型取决于type的值 payload: PayloadMap[K] } }[keyof PayloadMap] 单拎出来这一段，其实是map出了多个类型，一个key对应一个类型。然后Message通过keyof PayloadMap来获取到一个联合类型。
const MessageTypeMap = { [K in keyof PayloadMap]: { type: K nick: string id: string receiverId?</description></item></channel></rss>