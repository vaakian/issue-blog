<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TypeScript on Study Notes</title><link>https://note.vaakian.com/categories/typescript/</link><description>Recent content in TypeScript on Study Notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 15 Apr 2022 13:36:51 +0800</lastBuildDate><atom:link href="https://note.vaakian.com/categories/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title>TypeScript: Covariance &amp; Contravariance</title><link>https://note.vaakian.com/frontend/covariance-and-contravariance/</link><pubDate>Fri, 15 Apr 2022 13:36:51 +0800</pubDate><guid>https://note.vaakian.com/frontend/covariance-and-contravariance/</guid><description>个人复习用，不做科普。
创建两个类，Dog是Animal的子类。
class Animal {} class Dog extends Animal { bark() {} } 实现一个判断类型的Type，判断T是否是U的子类。
type Assignable&amp;lt;T, U&amp;gt; = T extends U ? true : false 测试，符合结果。
type R4 = Assignable&amp;lt;Dog, Animal&amp;gt; // true 但将同样的问题放到函数的parameters上，就发生了与第一直觉不一样的情况。
type ConsumeAnimal = (target: Animal) =&amp;gt; Animal type ConsumeDog = (target: Dog) =&amp;gt; Dog type R1 = Assignable&amp;lt;Son, Father&amp;gt; // false type R2 = Assignable&amp;lt;Father, Son&amp;gt; // true type R3 = Assignable&amp;lt;Parameters&amp;lt;Son&amp;gt;, Parameters&amp;lt;Father&amp;gt;&amp;gt; // true 问题出在哪里？ 通过Google，找到两个关键词：covariance和contravariance</description></item><item><title>TypeScript</title><link>https://note.vaakian.com/frontend/typescript/</link><pubDate>Fri, 21 Jan 2022 21:15:58 +0800</pubDate><guid>https://note.vaakian.com/frontend/typescript/</guid><description>动态属性 对象动态属性 即某个对象的属性类型 依赖于 另外一个属性，当Message的type为offer时，payload的属性为RTCSessionDescriptionInit，而不是一个联合类型PeerInfo | RTCSessionDescriptionInit | RTCIceCandidateInit。
interface PeerInfo { id: string nick: string } interface PayloadMap { join: PeerInfo offer: RTCSessionDescriptionInit answer: RTCSessionDescriptionInit icecandidate: RTCIceCandidateInit // leave只有单接受情况，客户端不会主动发送。 leave: PeerInfo } type Message = { [K in keyof PayloadMap]: { type: K nick: string receiverId?: string | null // playload的类型取决于type的值 payload: PayloadMap[K] } }[keyof PayloadMap] 单拎出来这一段，其实是map出了多个类型，一个key对应一个类型。然后Message通过keyof PayloadMap来获取到一个联合类型。
const MessageTypeMap = { [K in keyof PayloadMap]: { type: K nick: string id: string receiverId?</description></item></channel></rss>